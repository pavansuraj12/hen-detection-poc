<!DOCTYPE html>
<html>
<head>
  <title>YOLO Hen Detection (Final Stable PoC)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    body {
      margin: 0;
      padding: 0;
      background: #111;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
    }

    .camera-box {
      position: relative;
      width: 416px;
      height: 416px;
      margin: 20px auto;
      border: 2px solid #444;
    }

    video {
      width: 416px;
      height: 416px;
      display: block;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    button {
      padding: 10px 16px;
      margin: 6px;
      font-size: 14px;
    }

    .status {
      margin-top: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
  </style>
</head>

<body>

<h3>YOLO Hen Detection (Final Stable PoC)</h3>

<div class="camera-box">
  <video id="video" autoplay muted playsinline></video>
  <canvas id="overlay"></canvas>
</div>

<button onclick="startLive()">Start</button>
<button onclick="stopLive()">Stop</button>

<div class="status" id="status">Idle</div>

<script>
/* ================= CONFIG ================= */
const SIZE = 416;
const BACKEND_URL = "https://unraided-camren-streamingly.ngrok-free.dev/predict";

/* ================= ELEMENTS ================= */
const video = document.getElementById("video");
const overlay = document.getElementById("overlay");
const ctx = overlay.getContext("2d");
const statusText = document.getElementById("status");

/* ================= DPR FIX ================= */
const dpr = window.devicePixelRatio || 1;
overlay.width = SIZE * dpr;
overlay.height = SIZE * dpr;
overlay.style.width = SIZE + "px";
overlay.style.height = SIZE + "px";
ctx.scale(dpr, dpr);

/* ================= CAPTURE CANVAS ================= */
const captureCanvas = document.createElement("canvas");
captureCanvas.width = SIZE;
captureCanvas.height = SIZE;
const cctx = captureCanvas.getContext("2d");

/* ================= STATE ================= */
let running = false;
let detectTimer = null;

let rawDetections = [];
let smoothedDetections = [];

let lastRenderTime = performance.now();
let lastDetectTime = performance.now();

/* ================= ADAPTIVE FPS CONTROL ================= */
let detectIntervalMs = 400;
let rttEma = null;

const RTT_ALPHA = 0.2;
const MIN_INTERVAL = 250;
const MAX_INTERVAL = 800;
const MAX_STEP_CHANGE = 80;

/* ================= BOX SMOOTHING ================= */
const BOX_ALPHA = 0.4; // temporal smoothing factor
const BOX_TTL = 5;     // frames to persist boxes

/* ================= START ================= */
async function startLive() {
  if (running) return;

  statusText.innerText = "Starting camera...";

  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: "environment" } }
  });

  video.srcObject = stream;

  video.onloadedmetadata = () => {
    video.play();
    running = true;

    scheduleDetection();
    requestAnimationFrame(renderLoop);

    statusText.innerText = "Live detection";
  };
}

/* ================= STOP ================= */
function stopLive() {
  running = false;
  clearTimeout(detectTimer);
  detectTimer = null;

  if (video.srcObject) {
    video.srcObject.getTracks().forEach(t => t.stop());
    video.srcObject = null;
  }

  rawDetections = [];
  smoothedDetections = [];
  ctx.clearRect(0, 0, SIZE, SIZE);
  statusText.innerText = "Stopped";
}

/* ================= DETECTION SCHEDULER ================= */
function scheduleDetection() {
  if (!running) return;

  detectTimer = setTimeout(async () => {
    await runDetection();
    scheduleDetection();
  }, detectIntervalMs);
}

/* ================= DETECTION ================= */
async function runDetection() {
  if (!running || video.videoWidth === 0) return;

  cctx.drawImage(video, 0, 0, SIZE, SIZE);

  captureCanvas.toBlob(async blob => {
    if (!blob) return;

    const formData = new FormData();
    formData.append("image", blob, "frame.jpg");

    try {
      const res = await fetch(BACKEND_URL, { method: "POST", body: formData });
      const data = await res.json();

      rawDetections = data.detections.map(d => ({
        ...d,
        ttl: BOX_TTL
      }));

      /* ===== Adaptive FPS Stabilization ===== */
      const rtt = data.timing.total_ms;
      rttEma = rttEma === null ? rtt : RTT_ALPHA * rtt + (1 - RTT_ALPHA) * rttEma;

      let targetInterval = Math.round(rttEma * 2.2);
      targetInterval = Math.max(MIN_INTERVAL, Math.min(MAX_INTERVAL, targetInterval));

      const delta = targetInterval - detectIntervalMs;
      detectIntervalMs += Math.abs(delta) > MAX_STEP_CHANGE
        ? Math.sign(delta) * MAX_STEP_CHANGE
        : delta;

      lastDetectTime = performance.now();

    } catch {
      // Silent failure: keep last detections
    }
  }, "image/jpeg", 0.9);
}

/* ================= SMOOTHING ================= */
function smoothDetections() {
  const next = [];

  rawDetections.forEach((det, i) => {
    const prev = smoothedDetections[i];

    if (!prev) {
      next.push({ ...det });
    } else {
      next.push({
        ...det,
        bbox: det.bbox.map((v, j) =>
          BOX_ALPHA * v + (1 - BOX_ALPHA) * prev.bbox[j]
        )
      });
    }
  });

  smoothedDetections = next;
  rawDetections.forEach(d => d.ttl--);
  rawDetections = rawDetections.filter(d => d.ttl > 0);
}

/* ================= RENDER LOOP ================= */
function renderLoop() {
  if (!running) return;

  const now = performance.now();
  const renderFps = 1000 / (now - lastRenderTime);
  lastRenderTime = now;

  smoothDetections();

  ctx.clearRect(0, 0, SIZE, SIZE);
  ctx.lineWidth = 2;
  ctx.font = "14px Arial";
  ctx.strokeStyle = "red";
  ctx.fillStyle = "red";

  smoothedDetections.forEach(det => {
    const [x1, y1, x2, y2] = det.bbox;
    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
    ctx.fillText(
      `Hen ${det.confidence.toFixed(2)}`,
      x1,
      Math.max(15, y1 - 5)
    );
  });

  statusText.innerText =
    `Render FPS: ${renderFps.toFixed(1)} | ` +
    `Detect Interval: ${Math.round(detectIntervalMs)} ms | ` +
    `RTT EMA: ${Math.round(rttEma || 0)} ms | ` +
    `Boxes: ${smoothedDetections.length}`;

  requestAnimationFrame(renderLoop);
}
</script>

</body>
</html>
