<!DOCTYPE html>
<html>
<head>
  <title>YOLO Hen Detection (Production)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    body {
      margin: 0;
      background: #111;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
    }

    h3 { margin-top: 12px; }

    .camera-box {
      position: relative;
      width: 416px;
      height: 416px;
      margin: 10px auto;
      border: 2px solid #333;
    }

    video, canvas {
      position: absolute;
      width: 416px;
      height: 416px;
      top: 0;
      left: 0;
    }

    button {
      padding: 10px 18px;
      margin: 6px;
      font-size: 14px;
    }

    #status {
      margin-top: 8px;
      font-size: 13px;
      opacity: 0.9;
    }
  </style>
</head>

<body>

<h3>YOLO Hen Detection (Production-Grade)</h3>

<div class="camera-box">
  <video id="video" autoplay muted playsinline></video>
  <canvas id="canvas"></canvas>
</div>

<button onclick="start()">Start</button>
<button onclick="stop()">Stop</button>

<div id="status">Idle</div>

<script>
/* ================= CONFIG ================= */
const SIZE = 416;
const SEND_INTERVAL = 350;      // ms (stable)
const FADE_IN = 0.15;
const FADE_OUT = 0.06;
const SMOOTHING = 0.6;
const MAX_MISSES = 10;

/* =============== ELEMENTS ================= */
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const statusText = document.getElementById("status");

/* =============== STATE ==================== */
let timer = null;
let tracks = {};
let lastFrame = performance.now();

/* =============== START ==================== */
async function start() {
  if (timer) return;

  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: "environment" } }
  });

  video.srcObject = stream;
  video.onloadedmetadata = () => {
    canvas.width = SIZE;
    canvas.height = SIZE;
    timer = setInterval(sendFrame, SEND_INTERVAL);
    statusText.innerText = "Live detection";
  };
}

/* =============== STOP ===================== */
function stop() {
  clearInterval(timer);
  timer = null;
  ctx.clearRect(0,0,SIZE,SIZE);
  tracks = {};
  if (video.srcObject) {
    video.srcObject.getTracks().forEach(t => t.stop());
    video.srcObject = null;
  }
  statusText.innerText = "Stopped";
}

/* =============== SEND FRAME =============== */
function sendFrame() {
  ctx.drawImage(video, 0, 0, SIZE, SIZE);

  canvas.toBlob(blob => {
    const fd = new FormData();
    fd.append("image", blob);

    fetch("https://unraided-camren-streamingly.ngrok-free.dev/predict", {
      method: "POST",
      body: fd
    })
    .then(r => r.json())
    .then(updateTracks)
    .catch(() => statusText.innerText = "Network error");
  }, "image/jpeg", 0.9);
}

/* =============== TRACK UPDATE ============= */
function updateTracks(data) {
  const now = performance.now();
  const dt = (now - lastFrame) / 1000;
  lastFrame = now;

  const seen = new Set();

  data.detections.forEach(det => {
    const id = det.id ?? det.class; // fallback safe
    const [x1,y1,x2,y2] = det.bbox;
    const cx = (x1+x2)/2, cy=(y1+y2)/2;
    const w = x2-x1, h=y2-y1;

    if (!tracks[id]) {
      tracks[id] = {
        x: cx, y: cy, w, h,
        vx: 0, vy: 0,
        alpha: 0,
        misses: 0
      };
    }

    const t = tracks[id];

    t.vx = (cx - t.x) / dt;
    t.vy = (cy - t.y) / dt;

    t.x += (cx - t.x) * SMOOTHING;
    t.y += (cy - t.y) * SMOOTHING;
    t.w += (w - t.w) * SMOOTHING;
    t.h += (h - t.h) * SMOOTHING;

    t.alpha = Math.min(1, t.alpha + FADE_IN);
    t.misses = 0;

    seen.add(id);
  });

  Object.keys(tracks).forEach(id => {
    const t = tracks[id];
    if (!seen.has(id)) {
      t.x += t.vx * dt;
      t.y += t.vy * dt;
      t.alpha -= FADE_OUT;
      t.misses++;
      if (t.misses > MAX_MISSES || t.alpha <= 0) {
        delete tracks[id];
      }
    }
  });

  draw();
}

/* =============== DRAW ===================== */
function draw() {
  ctx.clearRect(0,0,SIZE,SIZE);

  Object.values(tracks).forEach(t => {
    ctx.globalAlpha = t.alpha;
    ctx.strokeStyle = "#00ff00";
    ctx.lineWidth = 2;

    ctx.strokeRect(
      t.x - t.w/2,
      t.y - t.h/2,
      t.w,
      t.h
    );
  });

  ctx.globalAlpha = 1.0;
  statusText.innerText = `Active tracks: ${Object.keys(tracks).length}`;
}
</script>

</body>
</html>
